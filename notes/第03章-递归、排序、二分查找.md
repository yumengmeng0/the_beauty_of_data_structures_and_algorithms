# 第3章 递归、排序、二分查找

## 3.1 递归：如何3行代码找到“最终推荐人”

### 3.1.1 什么是递归

```java
    int f(int n) {
        if (n == 1) return 1;
        return f(n - 1) + 1;
    }
```

### 3.1.2 递归需要满足3个条件
(1) 待求解问题的解可以分解为几个子问题的解。  
(2) 待求解问题与分解之后的子问题，只有数据规模不同，求解思路完全相同。
(3) 存在递归终止条件。

### 3.1.3 如何编写递归代码
* 找到将大问题分解为小问题的规律，并且基于此写出递推公式，然后推敲终止条件，最后将递推公式和终止条件“翻译”成代码。

### 3.1.4 编写递归代码难点
* 屏蔽递归细节，不要试图用人脑去分解递归的每个步骤，通过总结递推公式来写递归代码，这才是编写递归代码的正确方式。
### 3.1.5 警惕递归代码出现堆栈溢出
* 限制递归深度
### 3.1.6 警惕递归代码的重复计算问题
* 保存前面计算结果。

## 3.2 尾递归：如何借助尾递归避免递归过深导致的堆栈溢出
* 尾递归定义：  
如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。
当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，
这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，
因为大多数现代的编译器会利用这种特点自动生成优化的代码。

### 3.2.1 递归产生堆栈溢出的原因
```java
    // 求n的阶乘的递归代码
    int f(int n) {
        if (n < 1) return 1;
        return n * f(n - 1);
    }
```
### 3.2.2 什么样的递归代码可以改写为尾递归
* 一般情况下，只有递归调用出现在函数的最后一行，并且没有任何局部变量参与最后一行代码的计算，
这样的递归代码才可以改写成尾递归。

```java
    // 求n的阶乘的尾递归代码
    int f(int n, int res) {
        if (n <= 1) return res;
        return f(n - 1, n * res);
    }
```
### 3.2.3 尾递归真的可以避免堆栈溢出吗
* 尾递归优化需要编程语言的支持

## 3.3 排序算法的基础：从那几个方面分析排序算法
### 3.3.1 排序算法的执行效率
1. 最好时间复杂度、最坏时间复杂度和平均时间复杂度
2. 时间复杂度的系数、常数和低阶
3. 比较次数和交换（或移动）次数

### 3.3.2 排序算法的内存销毁
* 原地排序和非原地排序

### 3.3.3 排序算法的稳定性

## 3.4 O(n^2)排序：为什么插入排序比冒泡排序更受欢迎
### 3.4.1 冒泡排序
* 满有序度 = 逆序度 + 有序度

### 3.4.2 插入排序

## 3.5 O(NlogN)排序：如何借助快速排序思想快速查找第K大元素
### 3.5.1 归并排序的原理与实现
* 分治思想
* 
### 3.5.2 归并排序的性能分析
* 归并排序是否稳定关键要看merge()函数，也就是两个有序子数组合并成一个有序数组这部分逻辑。
* 归并排序不是原地排序。

### 3.5.3 快速排序的

### 3.5.4 快速排序的性能分析
