# 第3章 递归、排序、二分查找

## 3.1 递归：如何3行代码找到“最终推荐人”

### 3.1.1 什么是递归

```java
    int f(int n) {
        if (n == 1) return 1;
        return f(n - 1) + 1;
    }
```

### 3.1.2 递归需要满足3个条件
(1) 待求解问题的解可以分解为几个子问题的解。  
(2) 待求解问题与分解之后的子问题，只有数据规模不同，求解思路完全相同。
(3) 存在递归终止条件。

### 3.1.3 如何编写递归代码
* 找到将大问题分解为小问题的规律，并且基于此写出递推公式，然后推敲终止条件，最后将递推公式和终止条件“翻译”成代码。

### 3.1.4 编写递归代码难点
* 屏蔽递归细节，不要试图用人脑去分解递归的每个步骤，通过总结递推公式来写递归代码，这才是编写递归代码的正确方式。
### 3.1.5 警惕递归代码出现堆栈溢出
* 限制递归深度
### 3.1.6 警惕递归代码的重复计算问题
* 保存前面计算结果。

## 3.2 尾递归：如何借助尾递归避免递归过深导致的堆栈溢出
* 尾递归定义：  
如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。
当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，
这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，
因为大多数现代的编译器会利用这种特点自动生成优化的代码。

### 3.2.1 递归产生堆栈溢出的原因
```java
    // 求n的阶乘的递归代码
    int f(int n) {
        if (n < 1) return 1;
        return n * f(n - 1);
    }
```
### 3.2.2 什么样的递归代码可以改写为尾递归
* 一般情况下，只有递归调用出现在函数的最后一行，并且没有任何局部变量参与最后一行代码的计算，
这样的递归代码才可以改写成尾递归。

```java
    // 求n的阶乘的尾递归代码
    int f(int n, int res) {
        if (n <= 1) return res;
        return f(n - 1, n * res);
    }
```
### 3.2.3 尾递归真的可以避免堆栈溢出吗
* 尾递归优化需要编程语言的支持

## 3.3 排序算法的基础：从那几个方面分析排序算法
### 3.3.1 排序算法的执行效率
1. 最好时间复杂度、最坏时间复杂度和平均时间复杂度
2. 时间复杂度的系数、常数和低阶
3. 比较次数和交换（或移动）次数

### 3.3.2 排序算法的内存销毁
* 原地排序和非原地排序

### 3.3.3 排序算法的稳定性

## 3.4 O(n^2)排序：为什么插入排序比冒泡排序更受欢迎
### 3.4.1 冒泡排序
* 满有序度 = 逆序度 + 有序度

### 3.4.2 插入排序

## 3.5 O(NlogN)排序：如何借助快速排序思想快速查找第K大元素
### 3.5.1 归并排序的原理与实现
* 分治思想
* 
### 3.5.2 归并排序的性能分析
* 归并排序是否稳定关键要看merge()函数，也就是两个有序子数组合并成一个有序数组这部分逻辑。
* 归并排序不是原地排序。
* 归并排序的执行效率与元素数组的有序程度无关。最好、最坏和平均情况时间复杂度都是O(nlogn)
### 3.5.3 快速排序的的原理和实现
* 快排不是文档排序算法
* 归并排序的处理过程是由下到上的，先处理子问题，再合并。快排相反。
### 3.5.4 快速排序的性能分析
* 原始数据已经有序，快排时间复杂度由O(nlogn)变为O(n^2)
* 快排递归实现的，需要函数调用栈空间。
* 空间复杂度
    * 分区均衡时：O(logn)
    * 最坏情况，原始数据完全有序：O(n)

## 3.6 线性排序：如何根据年龄给100万个用户排序

* 桶排序、计数排序、基数排序
* 时间复杂度：O(n)
* 不是基于比较的排序算法。
* 对排序的数据要求苛刻

### 3.6.1 桶排序
* 桶排序思想：先定义几个有序的“桶”，将要排序的数据分到这几个“桶”里，对每个“桶”里的数据单独进行排序，
再把每个“桶”里的数据按照顺序依次取出，组成的序列就是有序的了。
* 桶排序适合外部排序：数据存储在外部磁盘中，数据量比较大，而内存有限，无法将数据全部加载到内存中处理。

### 3.6.2 计数排序
* 技术排序是桶排序的一种特殊情况
* 适用场景：
    * 时间复杂度O(n + k)，k表示要排序的数据范围，适用于数据范围不大的情况
    * 只能给非负数排序（其他情况需要转化为非负数）
        
### 3.6.3 基数排序

## 3.7 排序优化：如何实现一个高性能的通用的排序函数
### 3.7.1 如何选择合适的排序算法

*表3-3 常用算法对比*  

| | 是原地排序？ | 是稳定排序？ | 平均时间复杂度 |
|:---:|:---:| :---: |:---:|
| 冒泡排序 | 是 | 是 | O(n^2) |
| 插入排序 | 是 | 是 | O(n^2) |
| 选择排序 | 是 | 否 | O(n^2) |
| 快速排序 | 是 | 否 | O(nlogn) |
| 归并排序 | 否 | 是 | O(nlogn) |
| 桶排序 | 否 | 是 |O(n + k)，k为数据范围 |
| 计数排序 | 否 | 是 | O(n) |
| 基数排序 | 否 | 是 | O(dn)，d为数据维度 |

### 3.7.2 如何优化快速排序
1. 三数取中法
2. 随机法

### 3.7.3 排序函数举例

## 3.8 二分查找：如何用最省内存的方式实现快速查找功能
### 3.8.1 无处不在的二分思想
### 3.8.2 O(logn)惊人的查找速度
### 3.8.3 二分查找的递归与非递归实现
### 3.8.4 二分查找应用场景的局限性

## 3.9 二分查找的变体：如何快速定位ip地址对应的归属地
